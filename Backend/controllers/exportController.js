const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const Warranty = require('../models/Warranty');
const Quote = require('../models/Quote');
const Invoice = require('../models/Invoice');
const ProductUnit = require('../models/ProductUnit');
const RetailerInventory = require('../models/RetailerInventory');

const Contact = require('../models/Contact');
const EmailLog = require('../models/EmailLog');
const BlogPost = require('../models/BlogPost');

const {
  streamPDF,
  streamCSV,
  streamExcel,
  PRODUCT_EXPORT_CONFIG,
  ORDER_EXPORT_CONFIG,
  USER_EXPORT_CONFIG,
  WARRANTY_EXPORT_CONFIG,
  QUOTE_EXPORT_CONFIG,
  INVOICE_EXPORT_CONFIG,
  CONTACT_EXPORT_CONFIG,
  EMAIL_LOG_EXPORT_CONFIG,
  BLOG_EXPORT_CONFIG,
  formatDate
} = require('../utils/exportUtils');

/**
 * Universal Export Controller
 * Provides PDF, CSV, and Excel export endpoints for all admin modules
 */

// ============================================
// Product Exports
// ============================================

exports.exportProducts = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.category) query.category = filters.category;
    if (filters.minPrice) query.price = { $gte: Number(filters.minPrice) };
    if (filters.maxPrice) {
      query.price = { ...query.price, $lte: Number(filters.maxPrice) };
    }
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    const cursor = Product.find(query).sort({ createdAt: -1 }).cursor();
    
    const metadata = {
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...PRODUCT_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'products');
  } catch (error) {
    console.error('Product export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export products', error: error.message });
  }
};

// ============================================
// Order Exports
// ============================================

exports.exportOrders = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    if (filters.orderStatus) query.orderStatus = filters.orderStatus;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    // Calculate total revenue efficiently
    const totalRevenueResult = await Order.aggregate([
      { $match: query },
      { $group: { _id: null, total: { $sum: '$totalAmount' } } }
    ]);
    const totalRevenue = totalRevenueResult[0]?.total || 0;
    
    const cursor = Order.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const metadata = {
      'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...ORDER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'orders');
  } catch (error) {
    console.error('Order export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export orders', error: error.message });
  }
};

// ============================================
// User Exports
// ============================================

exports.exportUsers = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.role) query.role = filters.role;
    if (filters.isApproved !== undefined) {
      query.isApproved = filters.isApproved === 'true';
    }
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    // Calculate stats efficiently
    const userStats = await User.aggregate([
      { $match: query },
      { $group: { _id: '$role', count: { $sum: 1 } } }
    ]);
    
    const statsMap = userStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const cursor = User.find(query)
      .select('-password')
      .sort({ createdAt: -1 })
      .cursor();
    
    const metadata = {
      'Admins': statsMap.admin || 0,
      'Retailers': statsMap.retailer || 0,
      'Regular Users': statsMap.user || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...USER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'users');
  } catch (error) {
    console.error('User export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export users', error: error.message });
  }
};

// ============================================
// Warranty Exports
// ============================================

exports.exportWarranties = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.purchaseDate = { $gte: new Date(start) };
    }
    if (end) {
      query.purchaseDate = { ...query.purchaseDate, $lte: new Date(end) };
    }
    
    const cursor = Warranty.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const statusStats = await Warranty.aggregate([
      { $match: query },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    const statsMap = statusStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const metadata = {
      'Pending': statsMap.pending || 0,
      'Approved': statsMap.approved || 0,
      'Rejected': statsMap.rejected || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...WARRANTY_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'warranties');
  } catch (error) {
    console.error('Warranty export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export warranties', error: error.message });
  }
};

// ============================================
// Quote Exports
// ============================================

exports.exportQuotes = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    const cursor = Quote.find(query)
      .populate('user', 'name email role')
      .sort({ createdAt: -1 })
      .cursor();
    
    const statusStats = await Quote.aggregate([
      { $match: query },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    const statsMap = statusStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const metadata = {
      'Pending': statsMap.pending || 0,
      'Responded': statsMap.responded || 0,
      'Accepted': statsMap.accepted || 0,
      'Rejected': statsMap.rejected || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...QUOTE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'quotes');
  } catch (error) {
    console.error('Quote export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export quotes', error: error.message });
  }
};

// ============================================
// Invoice Exports
// ============================================

exports.exportInvoices = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.invoiceDate = { $gte: new Date(start) };
    }
    if (end) {
      query.invoiceDate = { ...query.invoiceDate, $lte: new Date(end) };
    }
    
    const cursor = Invoice.find(query)
      .populate('user', 'name email')
      .sort({ invoiceDate: -1 })
      .cursor();
    
    const stats = await Invoice.aggregate([
      { $match: query },
      { 
        $group: { 
          _id: null, 
          totalAmount: { $sum: '$totalAmount' },
          paidCount: { 
            $sum: { $cond: [{ $eq: ['$paymentStatus', 'completed'] }, 1, 0] } 
          }
        } 
      }
    ]);
    
    const totalAmount = stats[0]?.totalAmount || 0;
    const paidInvoices = stats[0]?.paidCount || 0;
    
    const metadata = {
      'Paid Invoices': paidInvoices,
      'Total Amount': `₹${totalAmount.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...INVOICE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'invoices');
  } catch (error) {
    console.error('Invoice export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export invoices', error: error.message });
  }
};

// ============================================
// Product Units Exports
// ============================================

exports.exportProductUnits = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.stockType) query.stockType = filters.stockType;
    if (filters.productId) query.product = filters.productId;
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    const totalUnits = await ProductUnit.countDocuments(query);
    const cursor = ProductUnit.find(query)
      .populate('product', 'name category')
      .populate('currentOwner', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const config = {
      title: 'Product Units Export',
      columns: [
        { key: 'serialNumber', header: 'Serial Number', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'modelNumber', header: 'Model', width: 90 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'stockType', header: 'Stock Type', width: 80 },
        { key: 'currentOwner.name', header: 'Owner', width: 100 }
      ],
      csvFields: [
        { label: 'Serial Number', value: 'serialNumber' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Model Number', value: 'modelNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Stock Type', value: 'stockType' },
        { label: 'Warranty (Months)', value: 'warrantyPeriodMonths' },
        { label: 'Manufacturing Date', value: (row) => formatDate(row.manufacturingDate) }
      ],
      metadata: {
        'Total Units': totalUnits,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, cursor, config, format, 'product-units');
  } catch (error) {
    console.error('Product units export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export product units', error: error.message });
  }
};

// ============================================
// Retailer Inventory Exports
// ============================================

exports.exportRetailerInventory = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.retailerId) query.retailer = filters.retailerId;
    if (startDate) {
      query.purchaseDate = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.purchaseDate = { ...query.purchaseDate, $lte: new Date(endDate) };
    }
    
    const totalItems = await RetailerInventory.countDocuments(query);
    const cursor = RetailerInventory.find(query)
      .populate('retailer', 'name email')
      .populate('product', 'name')
      .populate('productUnit', 'serialNumber')
      .sort({ purchaseDate: -1 })
      .cursor();
    
    const config = {
      title: 'Retailer Inventory Export',
      columns: [
        { key: 'retailer.name', header: 'Retailer', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'productUnit.serialNumber', header: 'Serial', width: 100 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'purchaseDate', header: 'Purchase Date', width: 90, formatter: formatDate }
      ],
      csvFields: [
        { label: 'Retailer Name', value: 'retailer.name' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Serial Number', value: 'productUnit.serialNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Purchase Date', value: (row) => formatDate(row.purchaseDate) },
        { label: 'Sold Date', value: (row) => formatDate(row.soldDate) }
      ],
      metadata: {
        'Total Items': totalItems,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, cursor, config, format, 'retailer-inventory');
  } catch (error) {
    console.error('Retailer inventory export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export retailer inventory', error: error.message });
  }
};

// ============================================
// Analytics/Reports Exports
// ============================================

exports.exportSalesReport = async (req, res) => {
  try {
    const { format = 'pdf', startDate, endDate } = req.query;
    
    const query = { paymentStatus: 'completed' };
    if (startDate) query.createdAt = { $gte: new Date(startDate) };
    if (endDate) query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    
    // Calculate totals efficiently
    const stats = await Order.aggregate([
      { $match: query },
      { 
        $group: { 
          _id: null, 
          totalRevenue: { $sum: '$totalAmount' },
          count: { $sum: 1 }
        } 
      }
    ]);

    const totalRevenue = stats.length > 0 ? stats[0].totalRevenue : 0;
    const totalOrders = stats.length > 0 ? stats[0].count : 0;
    const avgOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;
    
    const cursor = Order.find(query)
      .populate('user', 'name email role')
      .populate('products.product', 'name')
      .sort({ createdAt: -1 })
      .cursor();
    
    const config = {
      title: 'Sales Report',
      columns: [
        { key: '_id', header: 'Order ID', width: 100, formatter: (v) => String(v).slice(-8).toUpperCase() },
        { key: 'user.name', header: 'Customer', width: 100 },
        { key: 'user.role', header: 'Type', width: 60 },
        { key: 'totalAmount', header: 'Amount', width: 80, align: 'right', formatter: (v) => `₹${v.toLocaleString('en-IN')}` },
        { key: 'isQuoteBased', header: 'Quote-Based', width: 70, formatter: (v) => v ? 'Yes' : 'No' },
        { key: 'createdAt', header: 'Date', width: 90, formatter: formatDate }
      ],
      csvFields: ORDER_EXPORT_CONFIG.csvFields,
      metadata: {
        'Total Orders': totalOrders,
        'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
        'Average Order Value': `₹${avgOrderValue.toFixed(2)}`,
        'Period': startDate && endDate ? `${formatDate(startDate)} to ${formatDate(endDate)}` : 'All Time',
        'Generated On': formatDate(new Date()),
        'Generated By': req.user.name
      }
    };
    
    await handleExport(res, cursor, config, format, 'sales-report');
  } catch (error) {
    console.error('Sales report export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export sales report', error: error.message });
  }
};

// ============================================
// Contact Exports
// ============================================

exports.exportContacts = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    const totalContacts = await Contact.countDocuments(query);
    const cursor = Contact.find(query).sort({ createdAt: -1 }).cursor();
    
    const metadata = {
      'Total Messages': totalContacts,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...CONTACT_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'messages');
  } catch (error) {
    console.error('Contact export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export messages', error: error.message });
  }
};

// ============================================
// Email Log Exports
// ============================================

exports.exportEmailLogs = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.emailType) query.emailType = filters.emailType;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.sentAt = { $gte: new Date(start) };
    }
    if (end) {
      query.sentAt = { ...query.sentAt, $lte: new Date(end) };
    }
    
    const totalLogs = await EmailLog.countDocuments(query);
    const cursor = EmailLog.find(query).sort({ sentAt: -1 }).cursor();
    
    const metadata = {
      'Total Logs': totalLogs,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...EMAIL_LOG_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'email-logs');
  } catch (error) {
    console.error('Email log export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export email logs', error: error.message });
  }
};

// ============================================
// Blog Exports
// ============================================

exports.exportBlogs = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.category) query.category = filters.category;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.publishDate = { $gte: new Date(start) };
    }
    if (end) {
      query.publishDate = { ...query.publishDate, $lte: new Date(end) };
    }
    
    const totalBlogs = await BlogPost.countDocuments(query);
    const cursor = BlogPost.find(query).sort({ publishDate: -1 }).cursor();
    
    const metadata = {
      'Total Posts': totalBlogs,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...BLOG_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'blog-posts');
  } catch (error) {
    console.error('Blog export error:', error);
    res.status(500).json({ message: 'Failed to export blog posts', error: error.message });
  }
};

// ============================================
// Helper Function
// ============================================

/**
 * Handle export based on format using streams
 */
async function handleExport(res, cursor, config, format, filename) {
  try {
    const timestamp = Date.now();
    
    switch (format.toLowerCase()) {
      case 'pdf':
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.pdf"`);
        await streamPDF(res, cursor, config);
        break;
        
      case 'csv':
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.csv"`);
        // For CSV, we need to map columns to fields if not provided
        if (!config.csvFields && config.columns) {
           // This logic should ideally be in streamCSV or config, but let's rely on config.columns
        }
        await streamCSV(res, cursor, config);
        break;
        
      case 'excel':
      case 'xlsx':
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.xlsx"`);
        await streamExcel(res, cursor, config);
        break;
        
      default:
        res.status(400).json({ message: 'Invalid format. Use pdf, csv, or excel' });
    }
  } catch (error) {
    console.error('Export error:', error);
    if (!res.headersSent) {
      res.status(500).json({ message: 'Export failed', error: error.message });
    }
  }
}

module.exports = exports;
