const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const Warranty = require('../models/Warranty');
const Quote = require('../models/Quote');
const Invoice = require('../models/Invoice');
const ProductUnit = require('../models/ProductUnit');
const RetailerInventory = require('../models/RetailerInventory');

const Contact = require('../models/Contact');
const EmailLog = require('../models/EmailLog');
const BlogPost = require('../models/BlogPost');

const {
  streamPDF,
  streamCSV,
  streamExcel,
  PRODUCT_EXPORT_CONFIG,
  ORDER_EXPORT_CONFIG,
  USER_EXPORT_CONFIG,
  WARRANTY_EXPORT_CONFIG,
  QUOTE_EXPORT_CONFIG,
  INVOICE_EXPORT_CONFIG,
  CONTACT_EXPORT_CONFIG,
  EMAIL_LOG_EXPORT_CONFIG,
  BLOG_EXPORT_CONFIG,
  formatDate
} = require('../utils/exportUtils');

/**
 * Universal Export Controller
 * Provides PDF, CSV, and Excel export endpoints for all admin modules
 */

// ============================================
// Product Exports
// ============================================

exports.exportProducts = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.category) query.category = filters.category;
    if (filters.minPrice) query.price = { $gte: Number(filters.minPrice) };
    if (filters.maxPrice) {
      query.price = { ...query.price, $lte: Number(filters.maxPrice) };
    }
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    const cursor = Product.find(query).sort({ createdAt: -1 }).cursor();
    
    const metadata = {
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...PRODUCT_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'products');
  } catch (error) {
    console.error('Product export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export products', error: error.message });
  }
};

// ============================================
// Order Exports
// ============================================

exports.exportOrders = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    if (filters.orderStatus) query.orderStatus = filters.orderStatus;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    // Calculate total revenue efficiently
    const totalRevenueResult = await Order.aggregate([
      { $match: query },
      { $group: { _id: null, total: { $sum: '$totalAmount' } } }
    ]);
    const totalRevenue = totalRevenueResult[0]?.total || 0;
    
    const cursor = Order.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const metadata = {
      'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...ORDER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'orders');
  } catch (error) {
    console.error('Order export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export orders', error: error.message });
  }
};

// ============================================
// User Exports
// ============================================

exports.exportUsers = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.role) query.role = filters.role;
    if (filters.isApproved !== undefined) {
      query.isApproved = filters.isApproved === 'true';
    }
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    // Calculate stats efficiently
    const userStats = await User.aggregate([
      { $match: query },
      { $group: { _id: '$role', count: { $sum: 1 } } }
    ]);
    
    const statsMap = userStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const cursor = User.find(query)
      .select('-password')
      .sort({ createdAt: -1 })
      .cursor();
    
    const metadata = {
      'Admins': statsMap.admin || 0,
      'Retailers': statsMap.retailer || 0,
      'Regular Users': statsMap.user || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...USER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'users');
  } catch (error) {
    console.error('User export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export users', error: error.message });
  }
};

// ============================================
// Warranty Exports
// ============================================

exports.exportWarranties = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.purchaseDate = { $gte: new Date(start) };
    }
    if (end) {
      query.purchaseDate = { ...query.purchaseDate, $lte: new Date(end) };
    }
    
    const cursor = Warranty.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const statusStats = await Warranty.aggregate([
      { $match: query },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    const statsMap = statusStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const metadata = {
      'Pending': statsMap.pending || 0,
      'Approved': statsMap.approved || 0,
      'Rejected': statsMap.rejected || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...WARRANTY_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'warranties');
  } catch (error) {
    console.error('Warranty export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export warranties', error: error.message });
  }
};

// ============================================
// Quote Exports
// ============================================

exports.exportQuotes = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    const cursor = Quote.find(query)
      .populate('user', 'name email role')
      .sort({ createdAt: -1 })
      .cursor();
    
    const statusStats = await Quote.aggregate([
      { $match: query },
      { $group: { _id: '$status', count: { $sum: 1 } } }
    ]);
    
    const statsMap = statusStats.reduce((acc, curr) => {
      acc[curr._id] = curr.count;
      return acc;
    }, {});
    
    const metadata = {
      'Pending': statsMap.pending || 0,
      'Responded': statsMap.responded || 0,
      'Accepted': statsMap.accepted || 0,
      'Rejected': statsMap.rejected || 0,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...QUOTE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'quotes');
  } catch (error) {
    console.error('Quote export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export quotes', error: error.message });
  }
};

// ============================================
// Invoice Exports
// ============================================

exports.exportInvoices = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.invoiceDate = { $gte: new Date(start) };
    }
    if (end) {
      query.invoiceDate = { ...query.invoiceDate, $lte: new Date(end) };
    }
    
    const cursor = Invoice.find(query)
      .populate('user', 'name email')
      .sort({ invoiceDate: -1 })
      .cursor();
    
    const stats = await Invoice.aggregate([
      { $match: query },
      { 
        $group: { 
          _id: null, 
          totalAmount: { $sum: '$totalAmount' },
          paidCount: { 
            $sum: { $cond: [{ $eq: ['$paymentStatus', 'completed'] }, 1, 0] } 
          }
        } 
      }
    ]);
    
    const totalAmount = stats[0]?.totalAmount || 0;
    const paidInvoices = stats[0]?.paidCount || 0;
    
    const metadata = {
      'Paid Invoices': paidInvoices,
      'Total Amount': `₹${totalAmount.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...INVOICE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'invoices');
  } catch (error) {
    console.error('Invoice export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export invoices', error: error.message });
  }
};

// ============================================
// Product Units Exports
// ============================================

exports.exportProductUnits = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.stockType) query.stockType = filters.stockType;
    if (filters.productId) query.product = filters.productId;
    if (startDate) {
      query.createdAt = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    }
    
    const totalUnits = await ProductUnit.countDocuments(query);
    const cursor = ProductUnit.find(query)
      .populate('product', 'name category')
      .populate('currentOwner', 'name email')
      .sort({ createdAt: -1 })
      .cursor();
    
    const config = {
      title: 'Product Units Export',
      columns: [
        { key: 'serialNumber', header: 'Serial Number', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'modelNumber', header: 'Model', width: 90 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'stockType', header: 'Stock Type', width: 80 },
        { key: 'currentOwner.name', header: 'Owner', width: 100 }
      ],
      csvFields: [
        { label: 'Serial Number', value: 'serialNumber' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Model Number', value: 'modelNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Stock Type', value: 'stockType' },
        { label: 'Warranty (Months)', value: 'warrantyPeriodMonths' },
        { label: 'Manufacturing Date', value: (row) => formatDate(row.manufacturingDate) }
      ],
      metadata: {
        'Total Units': totalUnits,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, cursor, config, format, 'product-units');
  } catch (error) {
    console.error('Product units export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export product units', error: error.message });
  }
};

// ============================================
// Retailer Inventory Exports
// ============================================

exports.exportRetailerInventory = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.retailerId) query.retailer = filters.retailerId;
    if (startDate) {
      query.purchaseDate = { $gte: new Date(startDate) };
    }
    if (endDate) {
      query.purchaseDate = { ...query.purchaseDate, $lte: new Date(endDate) };
    }
    
    const totalItems = await RetailerInventory.countDocuments(query);
    const cursor = RetailerInventory.find(query)
      .populate('retailer', 'name email')
      .populate('product', 'name')
      .populate('productUnit', 'serialNumber')
      .sort({ purchaseDate: -1 })
      .cursor();
    
    const config = {
      title: 'Retailer Inventory Export',
      columns: [
        { key: 'retailer.name', header: 'Retailer', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'productUnit.serialNumber', header: 'Serial', width: 100 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'purchaseDate', header: 'Purchase Date', width: 90, formatter: formatDate }
      ],
      csvFields: [
        { label: 'Retailer Name', value: 'retailer.name' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Serial Number', value: 'productUnit.serialNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Purchase Date', value: (row) => formatDate(row.purchaseDate) },
        { label: 'Sold Date', value: (row) => formatDate(row.soldDate) }
      ],
      metadata: {
        'Total Items': totalItems,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, cursor, config, format, 'retailer-inventory');
  } catch (error) {
    console.error('Retailer inventory export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export retailer inventory', error: error.message });
  }
};

// ============================================
// Analytics/Reports Exports
// ============================================

exports.exportSalesReport = async (req, res) => {
  try {
    const { format = 'pdf', startDate, endDate } = req.query;
    
    const query = { paymentStatus: 'completed' };
    if (startDate) query.createdAt = { $gte: new Date(startDate) };
    if (endDate) query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    
    // Calculate totals efficiently
    const stats = await Order.aggregate([
      { $match: query },
      { 
        $group: { 
          _id: null, 
          totalRevenue: { $sum: '$totalAmount' },
          count: { $sum: 1 }
        } 
      }
    ]);

    const totalRevenue = stats.length > 0 ? stats[0].totalRevenue : 0;
    const totalOrders = stats.length > 0 ? stats[0].count : 0;
    const avgOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0;
    
    const cursor = Order.find(query)
      .populate('user', 'name email role')
      .populate('products.product', 'name')
      .sort({ createdAt: -1 })
      .cursor();
    
    const config = {
      title: 'Sales Report',
      columns: [
        { key: '_id', header: 'Order ID', width: 100, formatter: (v) => String(v).slice(-8).toUpperCase() },
        { key: 'user.name', header: 'Customer', width: 100 },
        { key: 'user.role', header: 'Type', width: 60 },
        { key: 'totalAmount', header: 'Amount', width: 80, align: 'right', formatter: (v) => `₹${v.toLocaleString('en-IN')}` },
        { key: 'isQuoteBased', header: 'Quote-Based', width: 70, formatter: (v) => v ? 'Yes' : 'No' },
        { key: 'createdAt', header: 'Date', width: 90, formatter: formatDate }
      ],
      csvFields: ORDER_EXPORT_CONFIG.csvFields,
      metadata: {
        'Total Orders': totalOrders,
        'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
        'Average Order Value': `₹${avgOrderValue.toFixed(2)}`,
        'Period': startDate && endDate ? `${formatDate(startDate)} to ${formatDate(endDate)}` : 'All Time',
        'Generated On': formatDate(new Date()),
        'Generated By': req.user.name
      }
    };
    
    await handleExport(res, cursor, config, format, 'sales-report');
  } catch (error) {
    console.error('Sales report export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export sales report', error: error.message });
  }
};

// ============================================
// Contact Exports
// ============================================

exports.exportContacts = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.status) query.status = filters.status;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.createdAt = { $gte: new Date(start) };
    }
    if (end) {
      query.createdAt = { ...query.createdAt, $lte: new Date(end) };
    }
    
    const totalContacts = await Contact.countDocuments(query);
    const cursor = Contact.find(query).sort({ createdAt: -1 }).cursor();
    
    const metadata = {
      'Total Messages': totalContacts,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...CONTACT_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'messages');
  } catch (error) {
    console.error('Contact export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export messages', error: error.message });
  }
};

// ============================================
// Email Log Exports
// ============================================

exports.exportEmailLogs = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.emailType) query.emailType = filters.emailType;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.sentAt = { $gte: new Date(start) };
    }
    if (end) {
      query.sentAt = { ...query.sentAt, $lte: new Date(end) };
    }
    
    const totalLogs = await EmailLog.countDocuments(query);
    const cursor = EmailLog.find(query).sort({ sentAt: -1 }).cursor();
    
    const metadata = {
      'Total Logs': totalLogs,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...EMAIL_LOG_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'email-logs');
  } catch (error) {
    console.error('Email log export error:', error);
    if (!res.headersSent) res.status(500).json({ message: 'Failed to export email logs', error: error.message });
  }
};

// ============================================
// Blog Exports
// ============================================

exports.exportBlogs = async (req, res) => {
  try {
    const { format = 'pdf', filters = {}, startDate, endDate } = req.query;
    
    const query = {};
    if (filters.category) query.category = filters.category;
    
    const start = startDate || filters.startDate;
    const end = endDate || filters.endDate;

    if (start) {
      query.publishDate = { $gte: new Date(start) };
    }
    if (end) {
      query.publishDate = { ...query.publishDate, $lte: new Date(end) };
    }
    
    const totalBlogs = await BlogPost.countDocuments(query);
    const cursor = BlogPost.find(query).sort({ publishDate: -1 }).cursor();
    
    const metadata = {
      'Total Posts': totalBlogs,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...BLOG_EXPORT_CONFIG, metadata };
    
    await handleExport(res, cursor, config, format, 'blog-posts');
  } catch (error) {
    console.error('Blog export error:', error);
    res.status(500).json({ message: 'Failed to export blog posts', error: error.message });
  }
};

// ============================================
// Helper Function
// ============================================

/**
 * Handle export based on format using streams
 */
async function handleExport(res, cursor, config, format, filename) {
  try {
    const timestamp = Date.now();
    
    switch (format.toLowerCase()) {
      case 'pdf':
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.pdf"`);
        await streamPDF(res, cursor, config);
        break;
        
      case 'csv':
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.csv"`);
        // For CSV, we need to map columns to fields if not provided
        if (!config.csvFields && config.columns) {
           // This logic should ideally be in streamCSV or config, but let's rely on config.columns
        }
        await streamCSV(res, cursor, config);
        break;
        
      case 'excel':
      case 'xlsx':
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${timestamp}.xlsx"`);
        await streamExcel(res, cursor, config);
        break;
        
      default:
        res.status(400).json({ message: 'Invalid format. Use pdf, csv, or excel' });
    }
  } catch (error) {
    console.error('Export error:', error);
    if (!res.headersSent) {
      res.status(500).json({ message: 'Export failed', error: error.message });
    }
  }
}

// ============================================
// User 360 View Export
// ============================================

exports.exportUser360 = async (req, res) => {
  try {
    const { userId } = req.params;
    const PDFDocument = require('pdfkit');
    
    // Fetch user data
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Fetch all related data
    const [orders, quotes, warranties, inventory] = await Promise.all([
      Order.find({ user: userId })
        .populate('products.product')
        .sort({ createdAt: -1 })
        .lean(),
      Quote.find({ user: userId })
        .populate('products.product')
        .sort({ createdAt: -1 })
        .lean(),
      Warranty.find({ user: userId })
        .populate('product')
        .sort({ createdAt: -1 })
        .lean(),
      user.role === 'retailer' 
        ? RetailerInventory.find({ retailer: userId })
            .populate('product')
            .sort({ createdAt: -1 })
            .lean()
        : []
    ]);
    
    // Create PDF
    const doc = new PDFDocument({ margin: 50, size: 'A4' });
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="User_360_${user.name.replace(/\\s+/g, '_')}_${Date.now()}.pdf"`);
    
    doc.pipe(res);
    
    // Header
    doc.fontSize(24).font('Helvetica-Bold').text('User 360° View Report', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica').fillColor('#666').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
    doc.moveDown(2);
    
    // User Information Section
    doc.fontSize(16).font('Helvetica-Bold').fillColor('#000').text('User Information');
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');
    doc.text(`Name: ${user.name}`);
    doc.text(`Email: ${user.email}`);
    doc.text(`Role: ${user.role.toUpperCase()}`);
    doc.text(`Status: ${user.role === 'retailer' && !user.isApproved ? 'Pending Approval' : 'Active'}`);
    doc.text(`Member Since: ${new Date(user.createdAt).toLocaleDateString()}`);
    doc.text(`User ID: ${user._id}`);
    doc.moveDown(2);
    
    // Summary Statistics
    doc.fontSize(16).font('Helvetica-Bold').text('Summary Statistics');
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');
    
    const totalRevenue = orders.reduce((sum, order) => sum + order.totalAmount, 0);
    
    doc.text(`Total Orders: ${orders.length}`);
    doc.text(`Total Revenue: ₹${totalRevenue.toLocaleString()}`);
    doc.text(`Quote Requests: ${quotes.length}`);
    doc.text(`Warranties Registered: ${warranties.length}`);
    if (user.role === 'retailer') {
      doc.text(`Inventory Items: ${inventory.length}`);
      const soldItems = inventory.filter(i => i.status === 'sold').length;
      doc.text(`Items Sold: ${soldItems}`);
    }
    doc.moveDown(2);
    
    // Orders Section
    if (orders.length > 0) {
      doc.addPage();
      doc.fontSize(16).font('Helvetica-Bold').text('Orders History');
      doc.moveDown(1);
      
      orders.forEach((order, index) => {
        doc.fontSize(12).font('Helvetica-Bold').text(`Order #${index + 1}: ${order.orderNumber || order._id.toString().slice(-8)}`);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Date: ${new Date(order.createdAt).toLocaleDateString()}`);
        doc.text(`Total: ₹${order.totalAmount.toLocaleString()}`);
        doc.text(`Payment Status: ${order.paymentStatus}`);
        doc.text(`Items: ${order.products.length}`);
        
        // List products
        order.products.forEach((item, idx) => {
          const productName = item.product?.name || item.productId?.name || 'Unknown Product';
          doc.fontSize(9).text(`  ${idx + 1}. ${productName} - Qty: ${item.quantity} - ₹${item.price?.toLocaleString() || 'N/A'}`);
        });
        
        doc.moveDown(1);
        
        if ((index + 1) % 5 === 0 && index < orders.length - 1) {
          doc.addPage();
        }
      });
    }
    
    // Quotes Section
    if (quotes.length > 0) {
      doc.addPage();
      doc.fontSize(16).font('Helvetica-Bold').text('Quote Requests');
      doc.moveDown(1);
      
      quotes.forEach((quote, index) => {
        doc.fontSize(12).font('Helvetica-Bold').text(`Quote #${index + 1}: ${quote._id.toString().slice(-8)}`);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Date: ${new Date(quote.createdAt).toLocaleDateString()}`);
        doc.text(`Status: ${quote.status}`);
        doc.text(`Products Requested: ${quote.products.length}`);
        if (quote.quotedPrice) {
          doc.text(`Quoted Price: ₹${quote.quotedPrice.toLocaleString()}`);
        }
        
        doc.moveDown(1);
        
        if ((index + 1) % 8 === 0 && index < quotes.length - 1) {
          doc.addPage();
        }
      });
    }
    
    // Warranties Section
    if (warranties.length > 0) {
      doc.addPage();
      doc.fontSize(16).font('Helvetica-Bold').text('Warranty Registrations');
      doc.moveDown(1);
      
      warranties.forEach((warranty, index) => {
        doc.fontSize(12).font('Helvetica-Bold').text(`Warranty #${index + 1}`);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Product: ${warranty.productName || warranty.product?.name || 'N/A'}`);
        doc.text(`Serial Number: ${warranty.serialNumber}`);
        doc.text(`Model: ${warranty.modelNumber}`);
        doc.text(`Status: ${warranty.status}`);
        doc.text(`Registered: ${new Date(warranty.createdAt).toLocaleDateString()}`);
        
        doc.moveDown(1);
        
        if ((index + 1) % 10 === 0 && index < warranties.length - 1) {
          doc.addPage();
        }
      });
    }
    
    // Inventory Section (Retailers only)
    if (user.role === 'retailer' && inventory.length > 0) {
      doc.addPage();
      doc.fontSize(16).font('Helvetica-Bold').text('Inventory Items');
      doc.moveDown(1);
      
      inventory.forEach((item, index) => {
        doc.fontSize(12).font('Helvetica-Bold').text(`Item #${index + 1}`);
        doc.fontSize(10).font('Helvetica');
        doc.text(`Product: ${item.product?.name || 'N/A'}`);
        doc.text(`Status: ${item.status}`);
        doc.text(`Purchase Date: ${new Date(item.purchaseDate).toLocaleDateString()}`);
        doc.text(`Purchase Price: ₹${item.purchasePrice?.toLocaleString() || 'N/A'}`);
        if (item.soldDate) {
          doc.text(`Sold Date: ${new Date(item.soldDate).toLocaleDateString()}`);
          doc.text(`Selling Price: ₹${item.sellingPrice?.toLocaleString() || 'N/A'}`);
        }
        
        doc.moveDown(1);
        
        if ((index + 1) % 8 === 0 && index < inventory.length - 1) {
          doc.addPage();
        }
      });
    }
    
    // Footer
    doc.fontSize(8).fillColor('#999').text(
      'This is a confidential document generated by Telogica Admin System',
      50,
      doc.page.height - 50,
      { align: 'center' }
    );
    
    doc.end();
  } catch (error) {
    console.error('User 360 export error:', error);
    if (!res.headersSent) {
      res.status(500).json({ message: 'Failed to export user 360 report', error: error.message });
    }
  }
};

module.exports = exports;
