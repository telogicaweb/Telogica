const Product = require('../models/Product');
const Order = require('../models/Order');
const User = require('../models/User');
const Warranty = require('../models/Warranty');
const Quote = require('../models/Quote');
const Invoice = require('../models/Invoice');
const ProductUnit = require('../models/ProductUnit');
const RetailerInventory = require('../models/RetailerInventory');

const {
  generatePDF,
  generateCSV,
  generateExcel,
  PRODUCT_EXPORT_CONFIG,
  ORDER_EXPORT_CONFIG,
  USER_EXPORT_CONFIG,
  WARRANTY_EXPORT_CONFIG,
  QUOTE_EXPORT_CONFIG,
  INVOICE_EXPORT_CONFIG,
  formatDate
} = require('../utils/exportUtils');

/**
 * Universal Export Controller
 * Provides PDF, CSV, and Excel export endpoints for all admin modules
 */

// ============================================
// Product Exports
// ============================================

exports.exportProducts = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.category) query.category = filters.category;
    if (filters.minPrice) query.price = { $gte: Number(filters.minPrice) };
    if (filters.maxPrice) {
      query.price = { ...query.price, $lte: Number(filters.maxPrice) };
    }
    
    const products = await Product.find(query).sort({ createdAt: -1 }).lean();
    
    if (!products.length) {
      return res.status(404).json({ message: 'No products found' });
    }
    
    const metadata = {
      'Total Products': products.length,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...PRODUCT_EXPORT_CONFIG, metadata };
    
    await handleExport(res, products, config, format, 'products');
  } catch (error) {
    console.error('Product export error:', error);
    res.status(500).json({ message: 'Failed to export products', error: error.message });
  }
};

// ============================================
// Order Exports
// ============================================

exports.exportOrders = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    if (filters.orderStatus) query.orderStatus = filters.orderStatus;
    if (filters.startDate) {
      query.createdAt = { $gte: new Date(filters.startDate) };
    }
    if (filters.endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(filters.endDate) };
    }
    
    const orders = await Order.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!orders.length) {
      return res.status(404).json({ message: 'No orders found' });
    }
    
    const totalRevenue = orders.reduce((sum, order) => sum + order.totalAmount, 0);
    
    const metadata = {
      'Total Orders': orders.length,
      'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...ORDER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, orders, config, format, 'orders');
  } catch (error) {
    console.error('Order export error:', error);
    res.status(500).json({ message: 'Failed to export orders', error: error.message });
  }
};

// ============================================
// User Exports
// ============================================

exports.exportUsers = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.role) query.role = filters.role;
    if (filters.isApproved !== undefined) {
      query.isApproved = filters.isApproved === 'true';
    }
    
    const users = await User.find(query)
      .select('-password')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!users.length) {
      return res.status(404).json({ message: 'No users found' });
    }
    
    const userStats = {
      admins: users.filter(u => u.role === 'admin').length,
      retailers: users.filter(u => u.role === 'retailer').length,
      users: users.filter(u => u.role === 'user').length
    };
    
    const metadata = {
      'Total Users': users.length,
      'Admins': userStats.admins,
      'Retailers': userStats.retailers,
      'Regular Users': userStats.users,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...USER_EXPORT_CONFIG, metadata };
    
    await handleExport(res, users, config, format, 'users');
  } catch (error) {
    console.error('User export error:', error);
    res.status(500).json({ message: 'Failed to export users', error: error.message });
  }
};

// ============================================
// Warranty Exports
// ============================================

exports.exportWarranties = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.startDate) {
      query.purchaseDate = { $gte: new Date(filters.startDate) };
    }
    if (filters.endDate) {
      query.purchaseDate = { ...query.purchaseDate, $lte: new Date(filters.endDate) };
    }
    
    const warranties = await Warranty.find(query)
      .populate('user', 'name email')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!warranties.length) {
      return res.status(404).json({ message: 'No warranties found' });
    }
    
    const statusStats = {
      pending: warranties.filter(w => w.status === 'pending').length,
      approved: warranties.filter(w => w.status === 'approved').length,
      rejected: warranties.filter(w => w.status === 'rejected').length
    };
    
    const metadata = {
      'Total Warranties': warranties.length,
      'Pending': statusStats.pending,
      'Approved': statusStats.approved,
      'Rejected': statusStats.rejected,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...WARRANTY_EXPORT_CONFIG, metadata };
    
    await handleExport(res, warranties, config, format, 'warranties');
  } catch (error) {
    console.error('Warranty export error:', error);
    res.status(500).json({ message: 'Failed to export warranties', error: error.message });
  }
};

// ============================================
// Quote Exports
// ============================================

exports.exportQuotes = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.startDate) {
      query.createdAt = { $gte: new Date(filters.startDate) };
    }
    if (filters.endDate) {
      query.createdAt = { ...query.createdAt, $lte: new Date(filters.endDate) };
    }
    
    const quotes = await Quote.find(query)
      .populate('user', 'name email role')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!quotes.length) {
      return res.status(404).json({ message: 'No quotes found' });
    }
    
    const statusStats = {
      pending: quotes.filter(q => q.status === 'pending').length,
      responded: quotes.filter(q => q.status === 'responded').length,
      accepted: quotes.filter(q => q.status === 'accepted').length,
      rejected: quotes.filter(q => q.status === 'rejected').length
    };
    
    const metadata = {
      'Total Quotes': quotes.length,
      'Pending': statusStats.pending,
      'Responded': statusStats.responded,
      'Accepted': statusStats.accepted,
      'Rejected': statusStats.rejected,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...QUOTE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, quotes, config, format, 'quotes');
  } catch (error) {
    console.error('Quote export error:', error);
    res.status(500).json({ message: 'Failed to export quotes', error: error.message });
  }
};

// ============================================
// Invoice Exports
// ============================================

exports.exportInvoices = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.paymentStatus) query.paymentStatus = filters.paymentStatus;
    if (filters.startDate) {
      query.invoiceDate = { $gte: new Date(filters.startDate) };
    }
    if (filters.endDate) {
      query.invoiceDate = { ...query.invoiceDate, $lte: new Date(filters.endDate) };
    }
    
    const invoices = await Invoice.find(query)
      .populate('user', 'name email')
      .sort({ invoiceDate: -1 })
      .lean();
    
    if (!invoices.length) {
      return res.status(404).json({ message: 'No invoices found' });
    }
    
    const totalAmount = invoices.reduce((sum, inv) => sum + inv.totalAmount, 0);
    const paidInvoices = invoices.filter(i => i.paymentStatus === 'completed').length;
    
    const metadata = {
      'Total Invoices': invoices.length,
      'Paid Invoices': paidInvoices,
      'Total Amount': `₹${totalAmount.toLocaleString('en-IN')}`,
      'Generated On': formatDate(new Date()),
      'Generated By': req.user.name
    };
    
    const config = { ...INVOICE_EXPORT_CONFIG, metadata };
    
    await handleExport(res, invoices, config, format, 'invoices');
  } catch (error) {
    console.error('Invoice export error:', error);
    res.status(500).json({ message: 'Failed to export invoices', error: error.message });
  }
};

// ============================================
// Product Units Exports
// ============================================

exports.exportProductUnits = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.stockType) query.stockType = filters.stockType;
    if (filters.productId) query.product = filters.productId;
    
    const units = await ProductUnit.find(query)
      .populate('product', 'name category')
      .populate('currentOwner', 'name email')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!units.length) {
      return res.status(404).json({ message: 'No product units found' });
    }
    
    const config = {
      title: 'Product Units Export',
      columns: [
        { key: 'serialNumber', header: 'Serial Number', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'modelNumber', header: 'Model', width: 90 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'stockType', header: 'Stock Type', width: 80 },
        { key: 'currentOwner.name', header: 'Owner', width: 100 }
      ],
      csvFields: [
        { label: 'Serial Number', value: 'serialNumber' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Model Number', value: 'modelNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Stock Type', value: 'stockType' },
        { label: 'Warranty (Months)', value: 'warrantyPeriodMonths' },
        { label: 'Manufacturing Date', value: (row) => formatDate(row.manufacturingDate) }
      ],
      metadata: {
        'Total Units': units.length,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, units, config, format, 'product-units');
  } catch (error) {
    console.error('Product units export error:', error);
    res.status(500).json({ message: 'Failed to export product units', error: error.message });
  }
};

// ============================================
// Retailer Inventory Exports
// ============================================

exports.exportRetailerInventory = async (req, res) => {
  try {
    const { format = 'pdf', filters = {} } = req.query;
    
    // Build query from filters
    const query = {};
    if (filters.status) query.status = filters.status;
    if (filters.retailerId) query.retailer = filters.retailerId;
    
    const inventory = await RetailerInventory.find(query)
      .populate('retailer', 'name email')
      .populate('product', 'name')
      .populate('productUnit', 'serialNumber')
      .sort({ purchaseDate: -1 })
      .lean();
    
    if (!inventory.length) {
      return res.status(404).json({ message: 'No inventory found' });
    }
    
    const config = {
      title: 'Retailer Inventory Export',
      columns: [
        { key: 'retailer.name', header: 'Retailer', width: 110 },
        { key: 'product.name', header: 'Product', width: 120 },
        { key: 'productUnit.serialNumber', header: 'Serial', width: 100 },
        { key: 'status', header: 'Status', width: 80 },
        { key: 'purchaseDate', header: 'Purchase Date', width: 90, formatter: formatDate }
      ],
      csvFields: [
        { label: 'Retailer Name', value: 'retailer.name' },
        { label: 'Product Name', value: 'product.name' },
        { label: 'Serial Number', value: 'productUnit.serialNumber' },
        { label: 'Status', value: 'status' },
        { label: 'Purchase Date', value: (row) => formatDate(row.purchaseDate) },
        { label: 'Sold Date', value: (row) => formatDate(row.soldDate) }
      ],
      metadata: {
        'Total Items': inventory.length,
        'Generated On': formatDate(new Date())
      }
    };
    
    await handleExport(res, inventory, config, format, 'retailer-inventory');
  } catch (error) {
    console.error('Retailer inventory export error:', error);
    res.status(500).json({ message: 'Failed to export retailer inventory', error: error.message });
  }
};

// ============================================
// Analytics/Reports Exports
// ============================================

exports.exportSalesReport = async (req, res) => {
  try {
    const { format = 'pdf', startDate, endDate } = req.query;
    
    const query = { paymentStatus: 'completed' };
    if (startDate) query.createdAt = { $gte: new Date(startDate) };
    if (endDate) query.createdAt = { ...query.createdAt, $lte: new Date(endDate) };
    
    const orders = await Order.find(query)
      .populate('user', 'name email role')
      .populate('products.product', 'name')
      .sort({ createdAt: -1 })
      .lean();
    
    if (!orders.length) {
      return res.status(404).json({ message: 'No sales data found' });
    }
    
    const totalRevenue = orders.reduce((sum, order) => sum + order.totalAmount, 0);
    const avgOrderValue = totalRevenue / orders.length;
    
    const config = {
      title: 'Sales Report',
      columns: [
        { key: '_id', header: 'Order ID', width: 100, formatter: (v) => String(v).slice(-8).toUpperCase() },
        { key: 'user.name', header: 'Customer', width: 100 },
        { key: 'user.role', header: 'Type', width: 60 },
        { key: 'totalAmount', header: 'Amount', width: 80, align: 'right', formatter: (v) => `₹${v.toLocaleString('en-IN')}` },
        { key: 'isQuoteBased', header: 'Quote-Based', width: 70, formatter: (v) => v ? 'Yes' : 'No' },
        { key: 'createdAt', header: 'Date', width: 90, formatter: formatDate }
      ],
      csvFields: ORDER_EXPORT_CONFIG.csvFields,
      metadata: {
        'Total Orders': orders.length,
        'Total Revenue': `₹${totalRevenue.toLocaleString('en-IN')}`,
        'Average Order Value': `₹${avgOrderValue.toFixed(2)}`,
        'Period': startDate && endDate ? `${formatDate(startDate)} to ${formatDate(endDate)}` : 'All Time',
        'Generated On': formatDate(new Date()),
        'Generated By': req.user.name
      }
    };
    
    await handleExport(res, orders, config, format, 'sales-report');
  } catch (error) {
    console.error('Sales report export error:', error);
    res.status(500).json({ message: 'Failed to export sales report', error: error.message });
  }
};

// ============================================
// Helper Function
// ============================================

/**
 * Handle export based on format
 */
async function handleExport(res, data, config, format, filename) {
  try {
    switch (format.toLowerCase()) {
      case 'pdf':
        const pdfBuffer = await generatePDF(data, config);
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${Date.now()}.pdf"`);
        res.send(pdfBuffer);
        break;
        
      case 'csv':
        const csvString = generateCSV(data, { fields: config.csvFields });
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${Date.now()}.csv"`);
        res.send(csvString);
        break;
        
      case 'excel':
      case 'xlsx':
        const excelBuffer = generateExcel(data, { 
          columns: config.columns, 
          sheetName: config.title 
        });
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}-${Date.now()}.xlsx"`);
        res.send(excelBuffer);
        break;
        
      default:
        res.status(400).json({ message: 'Invalid format. Use pdf, csv, or excel' });
    }
  } catch (error) {
    throw error;
  }
}

module.exports = exports;
